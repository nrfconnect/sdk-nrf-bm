/*
 * Copyright (c) 2018-2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <stdbool.h>
#include <stdint.h>
#include <ble_gap.h>
#include <nrf_error.h>
#include <nrf_sdh_ble.h>
#include <psa/crypto.h>
#include <sdk_macros.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/byteorder.h>

#include <modules/nrf_ble_lesc.h>

LOG_MODULE_DECLARE(peer_manager, CONFIG_PEER_MANAGER_LOG_LEVEL);

/** @brief Descriptor of the peer public key. */
typedef struct {
	/** @brief Peer public key. Stored in little-endian. */
	uint8_t value[BLE_GAP_LESC_P256_PK_LEN];
	/** @brief Flag indicating that the public key has been requested to compute DH key. */
	bool is_requested;
	/** @brief Flag indicating that the public key is valid. */
	bool is_valid;
	/** @brief Flag indicating that the passkey key has been requested. */
	bool passkey_requested;
	/** @brief Flag indicating that the passkey display event has been received. */
	bool passkey_displayed;
} nrf_ble_lesc_peer_pub_key_t;

/**
 * @brief The maximum number of peripheral and central connections combined.
 *        This value is based on what the SoftDevice handler module uses.
 */
#define NRF_BLE_LESC_LINK_COUNT CONFIG_NRF_SDH_BLE_TOTAL_LINK_COUNT

/** LESC ECC Public Key. */
__ALIGN(4) static ble_gap_lesc_p256_pk_t m_lesc_public_key;
/** LESC ECC DH Key. */
__ALIGN(4) static ble_gap_lesc_dhkey_t m_lesc_dh_key;

/** Flag indicating that the module encountered an internal error. */
static bool m_ble_lesc_internal_error;
/** Flag indicating that the local ECDH key pair was generated. */
static bool m_keypair_generated;

/** ID of ECC private/public key pair. */
static psa_key_id_t m_keypair_id;
/** Array of pointers to peer public keys, used for LESC DH generation. */
static nrf_ble_lesc_peer_pub_key_t m_peer_keys[NRF_BLE_LESC_LINK_COUNT];

static bool m_lesc_oobd_own_generated;
/** LESC OOB data used in LESC OOB pairing mode. */
static ble_gap_lesc_oob_data_t m_ble_lesc_oobd_own;
static nrf_ble_lesc_peer_oob_data_handler m_lesc_oobd_peer_handler;

#define ECC_PUB_KEY_UNCOMPRESSED_FORMAT_MARKER 0x04
#define ECC_PUB_KEY_EXPORT_SIZE \
	PSA_EXPORT_PUBLIC_KEY_OUTPUT_SIZE(PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1), 256)
#define COORD_SIZE (BLE_GAP_LESC_P256_PK_LEN / 2)

/* Convert an ECC (secp256r1) public key from between big-endian and little-endian.
 * The two coordinates are converted individually.
 */
static void ecc_public_key_byte_order_invert(const uint8_t *raw_key_in, uint8_t *raw_key_out)
{
	sys_memcpy_swap(raw_key_out, raw_key_in, COORD_SIZE);
	sys_memcpy_swap(&raw_key_out[COORD_SIZE], &raw_key_in[COORD_SIZE], COORD_SIZE);
}

uint32_t nrf_ble_lesc_init(void)
{
	psa_status_t status;

	memset((void *)m_peer_keys, 0, sizeof(m_peer_keys));

	/* Ensure that psa_crypto has been initialized. */
	status = psa_crypto_init();
	if (status != PSA_SUCCESS) {
		LOG_ERR("psa_crypto_init() returned status %d", status);
		return NRF_ERROR_INTERNAL;
	}

	LOG_DBG("Initialized nrf_ble_lesc.");

	/* Reset module state. */
	m_ble_lesc_internal_error = false;
	m_keypair_generated = false;

	/* Generate ECC key pair. Only one key pair is automatically generated by this module. */
	return nrf_ble_lesc_keypair_generate();
}

uint32_t nrf_ble_lesc_keypair_generate(void)
{
	psa_status_t status;
	uint8_t pub_key[ECC_PUB_KEY_EXPORT_SIZE];
	size_t pub_key_len = 0;

	/* Check if any DH computation is pending */
	for (uint16_t i = 0; i < ARRAY_SIZE(m_peer_keys); i++) {
		if (m_peer_keys[i].is_valid) {
			return NRF_ERROR_BUSY;
		}
	}

	/* Update flag to indicate that there is no valid private key. */
	m_keypair_generated = false;
	m_lesc_oobd_own_generated = false;

	/* Destroy the previous key pair (if any), to free up memory. */
	status = psa_destroy_key(m_keypair_id);
	if (status != PSA_SUCCESS && status != PSA_ERROR_INVALID_HANDLE) {
		LOG_ERR("psa_destroy_key returned status %d", status);
	} else {
		m_keypair_id = 0;
	}

	LOG_DBG("Generating ECC key pair");

	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;

	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
	psa_set_key_bits(&key_attributes, 256);

	status = psa_generate_key(&key_attributes, &m_keypair_id);
	if (status != PSA_SUCCESS) {
		LOG_ERR("psa_generate_key() returned status %d", status);
		return NRF_ERROR_INTERNAL;
	}

	/* Export the raw representation of the public key. */
	status = psa_export_public_key(m_keypair_id, pub_key, sizeof(pub_key), &pub_key_len);
	if (status != PSA_SUCCESS) {
		LOG_ERR("psa_export_public_key() returned status %d", status);
		return NRF_ERROR_INTERNAL;
	}
	/* Convert from big-endian to little-endian.
	 * Drop the first byte indicating the serialization format.
	 */
	ecc_public_key_byte_order_invert(&pub_key[1], m_lesc_public_key.pk);

	/* Set the flag to indicate that there is a valid ECDH key pair generated. */
	m_keypair_generated = true;

	return NRF_SUCCESS;
}

uint32_t nrf_ble_lesc_own_oob_data_generate(void)
{
	uint32_t err_code = NRF_ERROR_INVALID_STATE;

	m_lesc_oobd_own_generated = false;

	if (m_keypair_generated) {
		err_code = sd_ble_gap_lesc_oob_data_get(BLE_CONN_HANDLE_INVALID, &m_lesc_public_key,
							&m_ble_lesc_oobd_own);
		if (err_code == NRF_SUCCESS) {
			m_lesc_oobd_own_generated = true;
		}
	}

	return err_code;
}

ble_gap_lesc_p256_pk_t *nrf_ble_lesc_public_key_get(void)
{
	ble_gap_lesc_p256_pk_t *p_lesc_pk = NULL;

	if (m_keypair_generated) {
		p_lesc_pk = &m_lesc_public_key;
	} else {
		LOG_ERR("Trying to access LESC public key that has not been generated yet.");
	}

	return p_lesc_pk;
}

ble_gap_lesc_oob_data_t *nrf_ble_lesc_own_oob_data_get(void)
{
	ble_gap_lesc_oob_data_t *p_lesc_oobd_own = NULL;

	if (m_lesc_oobd_own_generated) {
		p_lesc_oobd_own = &m_ble_lesc_oobd_own;
	} else {
		LOG_ERR("Trying to access LESC OOB data that have not been generated yet.");
	}

	return p_lesc_oobd_own;
}

void nrf_ble_lesc_peer_oob_data_handler_set(nrf_ble_lesc_peer_oob_data_handler handler)
{
	m_lesc_oobd_peer_handler = handler;
}

/**
 * @brief Function for calculating a DH key and responding to the DH key request on a given
 *        connection handle.
 *
 * @param[in]  p_peer_public_key  ECC peer public key, used to compute shared secret.
 * @param[in]  conn_handle        Connection handle.
 *
 * @retval NRF_SUCCESS        If the operation was successful.
 * @retval NRF_ERROR_INTERNAL If @ref psa_raw_key_agreement, or @ref psa_generate_random failed.
 * @returns Other error codes might be returned by @ref sd_ble_gap_lesc_dhkey_reply.
 * functions.
 */
static uint32_t compute_and_give_dhkey(nrf_ble_lesc_peer_pub_key_t *p_peer_public_key,
				       uint16_t conn_handle)
{
	psa_status_t status = PSA_ERROR_BAD_STATE;
	uint8_t *p_shared_secret = m_lesc_dh_key.key;
	size_t shared_secret_size;
	uint8_t pub_key[ECC_PUB_KEY_EXPORT_SIZE];

	/* Check if there is a valid generated and set a local ECDH public key. */
	if (!m_keypair_generated) {
		return NRF_ERROR_INTERNAL;
	}

	/* Check if the public_key is valid */
	if (p_peer_public_key->is_valid) {
		/* Add the uncompressed format marker. */
		pub_key[0] = ECC_PUB_KEY_UNCOMPRESSED_FORMAT_MARKER;

		/* Convert from little-endian to big-endian. */
		ecc_public_key_byte_order_invert(p_peer_public_key->value, &pub_key[1]);

		status = psa_raw_key_agreement(PSA_ALG_ECDH, m_keypair_id,
			pub_key, sizeof(pub_key),
			p_shared_secret, BLE_GAP_LESC_DHKEY_LEN, &shared_secret_size);
	}

	if ((status == PSA_SUCCESS) && (shared_secret_size == BLE_GAP_LESC_DHKEY_LEN)) {
		/* Convert secret from big-endian to little-endian. */
		sys_mem_swap(p_shared_secret, BLE_GAP_LESC_DHKEY_LEN);
	} else {
		LOG_ERR("psa_raw_key_agreement() returned status %d", status);

		LOG_WRN("Creating invalid shared secret to make LESC fail.");
		status = psa_generate_random(p_shared_secret, BLE_GAP_LESC_DHKEY_LEN);
		if (status != PSA_SUCCESS) {
			LOG_ERR("psa_generate_random() returned status %d", status);
			return NRF_ERROR_INTERNAL;
		}
	}

	LOG_INF("Calling sd_ble_gap_lesc_dhkey_reply on conn_handle: %d", conn_handle);
	return sd_ble_gap_lesc_dhkey_reply(conn_handle, &m_lesc_dh_key);
}

uint32_t nrf_ble_lesc_request_handler(void)
{
	uint32_t err_code = NRF_SUCCESS;

	/* If the LESC module is in an invalid state, a restart is required. */
	if (m_ble_lesc_internal_error) {
		return NRF_ERROR_INTERNAL;
	}

	for (uint16_t i = 0; i < NRF_BLE_LESC_LINK_COUNT; i++) {
		if (m_peer_keys[i].is_requested) {
			err_code = compute_and_give_dhkey(&m_peer_keys[i], i);
			m_peer_keys[i].is_requested = false;
			m_peer_keys[i].is_valid = false;
			m_peer_keys[i].passkey_requested = false;
			m_peer_keys[i].passkey_displayed = false;

			VERIFY_SUCCESS(err_code);
		}
	}

	return err_code;
}

/**
 * @brief Function for handling a DH key request event.
 *
 * @param[in]  conn_handle      Connection handle.
 * @param[in]  idx              Data index assigned to the connection handle.
 * @param[in]  p_dhkey_request  DH key request descriptor.
 *
 * @retval NRF_SUCCESS If the operation was successful.
 * @returns Other error codes might be returned by @ref sd_ble_gap_auth_key_reply, and
 *          @ref sd_ble_gap_disconnect.
 */
static uint32_t on_dhkey_request(uint16_t conn_handle, int idx,
				 ble_gap_evt_lesc_dhkey_request_t const *p_dhkey_request)
{
	uint32_t err_code = NRF_SUCCESS;
	const uint8_t *const p_public_raw = p_dhkey_request->p_pk_peer->pk;

	/* Don't allow to pair with remote peer which uses the same public key.
	 * Compare only X cordinate of the public key, bytes from 0 to 31.
	 */
	if (memcmp(m_lesc_public_key.pk, p_public_raw, BLE_GAP_LESC_P256_PK_LEN / 2) == 0) {
		LOG_WRN("Remote peer is using identical public key.");
		m_peer_keys[idx].is_valid = false;

		/* In case when we have gotten passkey requested then we will respond to it with the
		 * "NONE" key type to prevent us from going through Authentication Stage 1.
		 */
		if (m_peer_keys[idx].passkey_requested) {
			m_peer_keys[idx].passkey_requested = false;

			err_code = sd_ble_gap_auth_key_reply(conn_handle,
							     BLE_GAP_AUTH_KEY_TYPE_NONE, NULL);

			return err_code;

		}
		/* In case we have gotten passkey display event then we need to disconnect a link
		 * to prevent us from going through Authentication Stage 1.
		 */
		else if (m_peer_keys[idx].passkey_displayed) {
			m_peer_keys[idx].passkey_displayed = false;

			err_code = sd_ble_gap_disconnect(conn_handle,
							 BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
			if (err_code != NRF_SUCCESS && err_code != NRF_ERROR_INVALID_STATE) {
				return err_code;
			}

			return NRF_SUCCESS;
		}
	} else {
		memcpy(m_peer_keys[idx].value, p_public_raw, BLE_GAP_LESC_P256_PK_LEN);
		m_peer_keys[idx].is_valid = true;
	}

	m_peer_keys[idx].is_requested = true;

	return NRF_SUCCESS;
}

/**
 * @brief Function for setting LESC OOB data.
 *
 * @param[in]  conn_handle      Connection handle.
 *
 * @retval NRF_SUCCESS If the operation was successful.
 * @returns Other error codes might be returned by @ref sd_ble_gap_lesc_oob_data_set.
 */
static uint32_t lesc_oob_data_set(uint16_t conn_handle)
{
	uint32_t err_code;
	ble_gap_lesc_oob_data_t *p_lesc_oobd_own;
	ble_gap_lesc_oob_data_t *p_lesc_oobd_peer;

	p_lesc_oobd_own = (m_lesc_oobd_own_generated) ? &m_ble_lesc_oobd_own : NULL;
	p_lesc_oobd_peer =
		(m_lesc_oobd_peer_handler != NULL) ? m_lesc_oobd_peer_handler(conn_handle) : NULL;

	err_code = sd_ble_gap_lesc_oob_data_set(conn_handle, p_lesc_oobd_own, p_lesc_oobd_peer);
	return err_code;
}

void nrf_ble_lesc_on_ble_evt(ble_evt_t const *p_ble_evt)
{
	uint32_t err_code = NRF_SUCCESS;
	const uint16_t conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
	const int idx = nrf_sdh_ble_idx_get(conn_handle);

	__ASSERT(idx >= 0, "Invalid idx %d for conn_handle %#x, evt_id %#x",
		 idx, conn_handle, p_ble_evt->header.evt_id);

	switch (p_ble_evt->header.evt_id) {
	case BLE_GAP_EVT_DISCONNECTED:
		m_peer_keys[idx].is_valid = false;
		m_peer_keys[idx].is_requested = false;
		m_peer_keys[idx].passkey_requested = false;
		m_peer_keys[idx].passkey_displayed = false;

		break;

	case BLE_GAP_EVT_AUTH_KEY_REQUEST:
		if (p_ble_evt->evt.gap_evt.params.auth_key_request.key_type ==
		    BLE_GAP_AUTH_KEY_TYPE_PASSKEY) {
			m_peer_keys[idx].passkey_requested = true;
		}

		break;

	case BLE_GAP_EVT_PASSKEY_DISPLAY:
		m_peer_keys[idx].passkey_displayed = true;

		break;

	case BLE_GAP_EVT_LESC_DHKEY_REQUEST:
		LOG_DBG("BLE_GAP_EVT_LESC_DHKEY_REQUEST");

		if (p_ble_evt->evt.gap_evt.params.lesc_dhkey_request.oobd_req) {
			err_code = lesc_oob_data_set(conn_handle);
			if (err_code != NRF_SUCCESS) {
				LOG_ERR("sd_ble_gap_lesc_oob_data_set() returned error 0x%x.",
					      err_code);
				m_ble_lesc_internal_error = true;
			}
		}

		err_code = on_dhkey_request(conn_handle, idx,
					    &p_ble_evt->evt.gap_evt.params.lesc_dhkey_request);
		if (err_code != NRF_SUCCESS) {
			m_ble_lesc_internal_error = true;
		}
		break;

#if defined(CONFIG_PM_LESC_GENERATE_NEW_KEYS)
	case BLE_GAP_EVT_AUTH_STATUS:
		/* Generate new pairing keys. */
		err_code = nrf_ble_lesc_keypair_generate();
		if (err_code != NRF_SUCCESS) {
			m_ble_lesc_internal_error = true;
		}

		break;
#endif /* CONFIG_PM_LESC_GENERATE_NEW_KEYS */

	default:
		break;
	}
}
